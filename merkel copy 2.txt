How to Create TradingView Charts
The TradingView integration allows users to view Pyth prices on their own website. All Pyth prices made available through the TradingView integration are originating from Pythnet.

Choosing an Implementation Method for TradingView Integration
There are primarily two methods to integrate TradingView with your website to display Pyth prices:

1. Using the TradingView Widget
Advantages:
Simplicity: This is a plug-and-play solution which allows for quick integration. You won't need to engage in complex setup processes or handle any backend configurations.
Disadvantages:
Limited Customization: The widget comes as-is, and while you can change basic parameters like the symbol or theme, more advanced customizations are restricted.
2. Using the Datafeed URL with Charting Library
Advantages:
Deep Customization: Suited for those who need a deeper level of integration and customization. By utilizing the UDF-compatible URL, you can tailor the look, feel, and functionality of the chart to better fit your application's needs.
Disadvantages:
Added Complexity: Integrating the Charting Library requires more technical know-how and potentially more time compared to the simpler widget integration.
When deciding between the two, consider the user experience you want to provide, the technical expertise at hand, and the time you can allocate to the integration. For a rapid deployment with minimal adjustments, the TradingView Widget is the way to go. If you need more control and are prepared for a deeper dive into the implementation, the Datafeed URL with the Charting Library would be your best choice.

TradingView Widget
Add the following script(s) from TradingView to your website depending on your framework:
<!-- TradingView Widget BEGIN -->
<div class="tradingview-widget-container">
    <div id="tradingview"></div>
    <script
        type="text/javascript"
        src="https://s3.tradingview.com/tv.js"
    ></script>
    <script type="text/javascript">
        new TradingView.widget({
        autosize: true,
        symbol: "PYTH:BTCUSD",
        interval: "D",
        timezone: "Etc/UTC",
        theme: "light",
        style: "1",
        locale: "en",
        toolbar_bg: "#f1f3f6",
        enable_publishing: false,
        allow_symbol_change: true,
        container_id: "tradingview",
    });
    </script>
</div>
<!-- TradingView Widget END -->

Replace the symbol parameter with the Pyth symbol you want to display. For example, to display the price of Ethereum, use symbol: "PYTH:ETHUSD".

Replace the interval parameter with the time interval you want to display. For example, to display the price of Ethereum in 1-minute intervals, use interval: "1". Possible resolutions are daily (D or 1D, 2D ... ), weekly (1W, 2W ...), monthly (1M, 2M...) and an intra-day resolution – minutes(1, 2 ...).

Replace the timezone parameter with the timezone you want to display. For example, to display the price of Ethereum in the Eastern Time Zone, use timezone: "America/New_York".

Replace the theme parameter with the theme you want to display. For example, to display the price of Ethereum in dark mode, use theme: "dark".

There is a fully working open-source example of the TradingView integration by one of Pyth's contributors here. The example application is deployed here.

Note: The TradingView plug-and-play widget does not allow for much customization. If you want to customize the widget, you can use the TradingView Charting Library. Please see the next section for more details.

Using Datafeed URL with Charting Library
We also provide a UDF-compatible URL that follows the TradingView UDF spec. You can implement your own datafeed utilizing the API or use the built-in UDF adapter with the API. If you need a step-by-step guide, refer to the How to connect data via Datafeed API tutorial, or you can reference the example here, the main files that may be of interest are: datafeed.js and streaming.js.

The datafeed URL is here and documentation can be found here

Example
Symbol Info: https://benchmarks.pyth.network/v1/shims/tradingview/symbol_info
History: https://benchmarks.pyth.network/v1/shims/tradingview/history?symbol=Crypto.ETH/USD&resolution=1&from=1690338541&to=1690338741
Stream of prices: https://benchmarks.pyth.network/v1/shims/tradingview/streaming
Config: https://benchmarks.pyth.network/v1/shims/tradingview/config
Symbols: https://benchmarks.pyth.network/v1/shims/tradingview/symbols?symbol=Crypto.BTC/USD
Search: https://benchmarks.pyth.network/v1/shims/tradingview/search?query=bitcoin


Derive Cross Rate
This guide shows how to combine two price feeds to derive a cross rate. These are also known as "synthetic" price feeds. Cross rates or Synthetic Price feeds are useful for trading pairs that are not directly supported by Pyth.

EVM
For example, if you want to trade the price of ETH/EUR, which is not directly supported by Pyth, you can combine the price of ETH/USD and EUR/USD to derive the price of ETH/EUR.

ETH/EUR
=
ETH/USD
÷
EUR/USD
ETH/EUR=ETH/USD÷EUR/USD
Derive a cross rate
The Pyth Solidity SDK provides deriveCrossRate function to combine two price feeds. This method is available in Pyth solidity SDK.

This method takes the following parameters:

price1: The first price feed value, representing a / b (e.g., ETH/USD). Must be a signed integer (int64).
expo1: The exponent for price1, indicating the number of decimal places.
price2: The second price feed value, representing c / b (e.g., EUR/USD).
expo2: The exponent for price2.
targetExponent: The desired exponent for the output cross rate (a / c). The result will be scaled to this exponent.
Returns:

crossRate: The computed cross rate (a / c), scaled to targetExponent.
Example
pragma solidity ^0.8.0;
 
import "@pythnetwork/pyth-sdk-solidity/IPyth.sol";
import "@pythnetwork/pyth-sdk-solidity/PythStructs.sol";
import "@pythnetwork/pyth-sdk-solidity/PythUtils.sol";
 
contract ExampleCrossRate {
  IPyth public pyth;
 
  constructor(address _pythContract) {
    pyth = IPyth(_pythContract);
  }
 
  // priceUpdate should include both price feeds
  function getEthPerEur(
    bytes32 ethUsdId,
    bytes32 eurUsdId,
    bytes[] calldata priceUpdate
  ) external payable returns (int64 price, int32 expo) {
    // Update both feeds
    uint fee = pyth.getUpdateFee(priceUpdate);
    pyth.updatePriceFeeds{ value: fee }(priceUpdate);
 
    // Fetch prices
    PythStructs.Price memory ethUsd = pyth.getPriceNoOlderThan(ethUsdId, 60);
    PythStructs.Price memory eurUsd = pyth.getPriceNoOlderThan(eurUsdId, 60);
 
    // Derive ETH/EUR = ETH/USD / EUR/USD
    int32 targetExpo = -8;
    int64 ethPerEur = PythUtils.deriveCrossRate(
      ethUsd.price,
      ethUsd.expo,
      eurUsd.price,
      eurUsd.expo,
      targetExpo
    );
 
    return (ethPerEur, targetExpo);
  }
}
 
⚠️ Things to Keep in Mind
The function reverts if either price is negative, or if any exponent is less than -255.
The result is rounded down. If the result is smaller than 1 in the given targetExponent, it will return 0.
Confidence intervals are not derived in this function. If needed, you have to derive them manually.
Reverts with PythErrors.ExponentOverflow if targetExponent + expo1 - expo2 is outside the range [-58, 58].
Additional Resources
You may find these additional resources helpful.

How to use real-time data in EVM contracts
The How to use real-time data in EVM contracts guide provides a step-by-step guide on how to use real-time data in EVM contracts.

Price Feed IDs
The Price Feed IDs page lists the price feed IDs for each asset supported by Pyth.

Derive Cross Rate
This guide shows how to combine two price feeds to derive a cross rate. These are also known as "synthetic" price feeds. Cross rates or Synthetic Price feeds are useful for trading pairs that are not directly supported by Pyth.

SVM
The Pyth Rust SDK provides get_price_in_quote function to combine two price feeds. This method is available in Pyth Rust SDK.

Example
let btc_usd: Price = ...;
let eth_usd: Price = ...;
// -8 is the desired exponent for the result
let btc_eth: Price = btc_usd.get_price_in_quote(&eth_usd, -8);
println!("BTC/ETH price: ({} +- {}) x 10^{}", price.price, price.conf, price.expo);



API Reference
The API reference is a comprehensive guide to the various APIs -- both on- and off-chain -- that developers can use in their applications. Developers can consult this reference to better understand what methods exist and what they do. The API reference is interactive, so developers can try out the APIs from the website to better understand their behavior.

The following on-chain contracts are documented in the API reference:

EVM
Hermes also has interactive API documentation hosted by the service itself:

Hermes
Benchmarks / Historical Prices

Hermes
Hermes is an open-source service that listens to the Pythnet and the Wormhole Network for Pyth price updates, and serves them via a convenient web API.

Hermes allows users to easily fetch price updates via a REST API, or subscribe to server-side streaming updates.

Public Endpoints
The Pyth Data Association operates a public endpoint for Hermes, which can be used to test integrations with Pyth Network:

URL: https://hermes.pyth.network

For developers building on Aptos testnet, Sui testnet or Near testnet, please use the Hermes Beta endpoint:

URL: https://hermes-beta.pyth.network

Rate limits
In order to maximize the reliability of the Public Hermes API, a request rate limit is enforced. All endpoints limits are set at 30 requests every 10 seconds per IP address. Clients issuing request above the limit will receive a 429 (Too Many Requests) response for the subsequent 60-second period.

For production deployments, developers integrating with Pyth Network are strongly encouraged to use Node Providers for maximum resilience and decentralization. Moreover, Hermes is designed to be self-hosted, so developers can run their own instance of Hermes to fetch Pyth price updates.

Node Providers
The following node providers offer Hermes:

Triton
P2P
extrnode
Liquify
Self-Hosting
The Pyth Data Association provides a Helm chart for running Hermes in charts repository. Please refer to the chart's readme for the configuration values. You will need a Pythnet RPC to run Hermes; see the guide for accessing a Pythnet RPC.



# Trading Pairs

## **Crypto**

Available pairs: _See "Pair Information" below._

* Leverage minimum 3x to maximum 150x
* Trading of crypto assets is open 24 hours a day, 365 days a year.

## **Forex**

Available Pairs: **EUR/USD, JPY/USD, GBP/USD, AUD/USD, NZD/USD, CAD/USD, CHF/USD**

* Leverage minimum 10x to maximum 1000x
* Closed from Friday 9PM to Sunday 10PM (UTC).
* Closed 1st-3rd Jan. and 25th-27th Dec. every year.
* Please note that there can be price gaps between the market's closing and the next opening, and TP/SL, limit orders might not work as intended.

## Metals

Available pairs: **XAU/USD, XAG/USD**

* XAU/USD's leverage minimum 5x to maximum 250x
* XAG/USD's leverage minimum 5x to maximum 150x
* Closed from Friday 9PM to Sunday 11PM (UTC).
* Closed from 9PM to 11PM (UTC) every weekday.
* Closed 1st-3rd Jan. and 25th-27th Dec. every year.
* Please note that there can be price gaps between the market's closing and the next opening, and TP/SL limit orders might not work as intended.

{% hint style="warning" %}
**Temporary Leverage Limitation**

During major macroeconomic events, such as CPI announcements, when markets are likely to experience significant short-term volatility, we reduce the maximum leverage for forex and commodity pairs to 10% of the original limit. This adjustment is effective for 30 minutes before and after the event.
{% endhint %}

## Pair Information

Detailed risk parameters: [https://app.merkle.trade/markets/info](https://app.merkle.trade/markets/info)



# Merkle Trade TypeScript SDK (Beta)

> **Note:** This SDK is in beta. We are actively refining its features, so there may be occasional changes or issues.

A TypeScript SDK for interacting with the Merkle Trade protocol on the Aptos blockchain. This SDK provides a simple interface for trading, managing positions while interacting with the Merkle Trade protocol.

**Join our Telegram Group:** [@merkle_trade_dev](https://t.me/merkle_trade_dev) for latest updates and Q&A.

## Features

- Transaction Payloads for trading
- Calculation utilities for trading
- Merkle APIs (positions, orders, etc.)
- Merkle Websocket APIs (price feeds, account updates)

## Installation

```bash
npm install @merkletrade/ts-sdk

// or

yarn add @merkletrade/ts-sdk

// or

pnpm add @merkletrade/ts-sdk
```

## Quick Start

```typescript
import { MerkleClient, MerkleClientConfig } from "@merkletrade/ts-sdk";
import { Aptos } from "@aptos-labs/ts-sdk";

// initialize clients

const merkle = new MerkleClient(await MerkleClientConfig.testnet());
const aptos = new Aptos(merkle.config.aptosConfig);

// initialize account (refer to Aptos docs)

const account = ...

// Place a market order

const order = await merkle.payloads.placeMarketOrder({
  pair: "BTC_USD",
  userAddress: account.accountAddress,
  sizeDelta: 300_000_000n, // 300 USDC
  collateralDelta: 5_000_000n, // 5 USDC
  isLong: true,
  isIncrease: true,
});

// submit transaction

const committedTransaction = await aptos.transaction.build
  .simple({ sender: account.accountAddress, data: payload })
  .then((transaction) =>
    aptos.signAndSubmitTransaction({ signer: account, transaction }),
  )
  .then(({ hash }) => aptos.waitForTransaction({ transactionHash: hash }));

console.log(committedTransaction);
console.log("Successfully placed order!");
```

## API Catalog

### Client Configuration

```typescript
const merkle = new MerkleClient(await MerkleClientConfig.mainnet());
const aptos = new Aptos(merkle.config.aptosConfig);
```

### Trading Payloads

- `placeMarketOrder`
- `placeLimitOrder`
- `cancelOrder`
- `updateTPSL`
- `testnetFaucet`

See [examples/place-order.ts](examples/place-order.ts) for basic usage.

### Merkle APIs

- `getSummary`
- `getPairInfo`
- `getAllPairInfos`
- `getPairState`
- `getAllPairStates`
- `getOrders`
- `getPositions`
- `getTradingHistory`
- `postFeepayer`

### Merkle Websocket APIs

Real-time price feeds and account updates (positions, orders) are available via websocket.

- `subscribePriceFeed`
- `subscribeAccountFeed`

See [examples/ws.ts](examples/ws.ts) for more details.

### Calculation Utilities

- `calcNewPrice`
- `calcPnlWithoutFee`
- `calcPriceImpact`
- `calcRolloverFee`
- `calcFundingRate`
- `calcAccFundingFeePerSize`
- `calcFundingFee`
- ...

See [src/calc/*](src/calc/) for more details.

### Aptos Helper Methods

- `getUsdcBalance`

## Environment
- [Mainnet](https://app.merkle.trade)
- [Testnet](https://app.testnet.merkle.trade)



# Contract Addresses

## Deployer Account

<pre><code><strong>0x5ae6789dd2fec1a9ec9cccfb3acaf12e93d432f0a3a42c92fe1a9d490b7bbc06
</strong></code></pre>

All move modules (smart contracts) related to Merkle Trade protocol are deployed under the deployer account.

## Token Addresses

{% hint style="info" %}
**Fungible Asset vs Coin**: On the Aptos blockchain, there are two standards for fungible tokens: [Fungible Asset](https://aptos.dev/en/build/smart-contracts/fungible-asset) (the new standard) and [Coin](https://aptos.dev/en/build/smart-contracts/aptos-coin) (the legacy standard).

For the MKL token, there are two addresses—one for the Fungible Asset and one for the Coin—but they both represent the same token. Please refer to the [Aptos docs](https://aptos.dev/en/build/smart-contracts/fungible-asset#migration-from-coin-to-the-fungible-asset-standard) for more info about the migration.
{% endhint %}

### MKL

Fungible Asset

<pre><code><strong>0x5ae6789dd2fec1a9ec9cccfb3acaf12e93d432f0a3a42c92fe1a9d490b7bbc06
</strong></code></pre>

Coin (Legacy)

```
0x5ae6789dd2fec1a9ec9cccfb3acaf12e93d432f0a3a42c92fe1a9d490b7bbc06::mkl_token::MKL
```

### MKLP Token

Coin (legacy)

```
0x5ae6789dd2fec1a9ec9cccfb3acaf12e93d432f0a3a42c92fe1a9d490b7bbc06::house_lp::MKLP<0x5ae6789dd2fec1a9ec9cccfb3acaf12e93d432f0a3a42c92fe1a9d490b7bbc06::fa_box::W_USDC>
```

#### esMKL

Fungible Asset

```
0x3b5200e090d188c274e06b0d64b3f66638fb996fb0b350499975ff36b1f4595
```


